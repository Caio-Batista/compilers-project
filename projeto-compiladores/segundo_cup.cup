import java_cup.runtime.*;



parser code {:

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
                   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            m.append(" in line "+(s.left));
            m.append(", column "+(s.right));

        }

        m.append(" : "+message);

        /* Print the contents of the StringBuilder 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
    }
    /*

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
    */
:};

// terminais
terminal CLASS, EXTENDS, IMPLEMENTS, INTERFACE, NEW, BREAK, CASE;
terminal CONTINUE, DEFAULT, DO, IF, ELSE, FOR, RETURN, SWITCH;
terminal WHILE, ASSERT, TRY, CATCH, FINALLY, THROW, THROWS, IMPORT;
terminal PACKAGE, BYTE, CONST, ABSTRACT, FINAL, NATIVE, SYNCHRONIZED;
terminal TRANSIENT, VOLATILE,SUPER, STRICTFP, PUBLIC, PROTECTED, PRIVATE;
terminal STATIC, VOID, NULL, THIS, INSTANCEOF, BOOLEAN, URSHIFTEQ;
terminal CHAR, SHORT, INT, FLOAT, LONG, DOUBLE, STRING, TRUE, FALSE;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON;
terminal COMMA, DOT, EQUAL, GREATER, LESS, NOT, BITNOT, QUESTION;
terminal COLON, EQEQ, LTEQ, GTEQ,GOTO, NOTEQ, ANDAND, OROR, PLUSPLUS;
terminal MINUSMINUS, PLUS, MINUS, MULT, DIV, AND, OR, XOR, MOD;
terminal LSHIFT, RSHIFT, URSHIFT, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, input_character, escape_character;
terminal ANDEQ, OREQ, XOREQ, MODEQ, LSHIFTEQ, RSHIFTEQ, ID, NUMERO, COMENTARIO;
terminal  a , b , c , d , e , f , A , B , C , D , E , F, x, X, l, L, escape_sequence, except;
terminal STRING_LITERAL;
// nao terminais


non terminal arglist, bit_expression, casting_expression, character;
non terminal class_declaration, class_name, compilation_unit, constructor_declaration;
non terminal creating_expression,decimal_digits,doc_comment,do_statement;
non terminal exponent_part,expression,field_declaration,float_literal;
non terminal float_type_suffix,for_statement,identifier,if_statement;
non terminal import_statement,integer_literal,interface_declaration,interface_name;
non terminal literal_expression,logical_expression,method_declaration,modifier;
non terminal numeric_expression,package_name,package_statement,parameter;
non terminal parameter_list,statement,statement_block,static_initializer;
non terminal string, string_expression,switch_statement,testing_expression;
non terminal try_statement,type, type_declaration,type_specifier, variable_declaration;
non terminal variable_declarator, variable_initializer, hile_statement;






arglist ::= expression { "," expression }
bit_expression ::= ( "~" expression ) | ( expression ( ">>=" | "<<" | ">>" | ">>>" ) expression )
casting_expression ::= "(" type ")" expression
character ::= "based on the unicode character set"
class_declaration ::= { modifier } "class" identifier [ "extends" class_name ] [ "implements" interface_name { "," interface_name } ] "{" { field_declaration } "}"
class_name ::= identifier | ( package_name "." identifier )
compilation_unit ::= [ package_statement ] { import_statement } { type_declaration }
constructor_declaration ::= { modifier } identifier "(" [ parameter_list ] ")" statement_block
creating_expression ::= "new" ( ( classe_name "(" [ arglist ] ")" ) | ( type_specifier [ "[" expression "]" ] { "[" "]" } ) | ( "(" expression ")" ) )
decimal_digits ::= "0..9" { "0..9" }
doc_comment ::= "/**" "... text ..." "*/"
do_statement ::= "do" statement "while" "(" expression ")" ";"
exponent_part ::= "e" [ "+" | "-" ] decimal_digits
expression ::= numeric_expression | testing_expression | logical_expression | string_expression | bit_expression | casting_expression | creating_expression | literal_expression | "null" | "super" | "this" | identifier | ( "(" expression ")" ) | ( expression ( ( "(" [ arglist ] ")" ) | ( "[" expression "]" ) | ( "." expression ) | ( "," expression ) | ( "instanceof" ( class_name | interface_name ) ) ) )
field_declaration ::= ( [ doc_comment ] ( method_declaration | constructor_declaration | variable_declaration ) ) | static_initializer | ";"
float_literal  ::=  ( decimal_digits "." [ decimal_digits ] [ exponent_part ] [ float_type_suffix ] ) | ( "." decimal_digits [ exponent_part ] [ float_type_suffix ] ) | ( decimal_digits [ exponent_part ] [ float_type_suffix ] )



float_type_suffix ::= "f" | "d"
for_statement ::= "for" "(" ( variable_declaration | ( expression ";" ) | ";" ) [ expression ] ";"  [ expression ] ";" ")" statement
identifier ::= "a..z,$,_" { "a..z,$,_,0..9,unicode character over 00C0" }
if_statement ::= "if" "(" expression ")" statement [ "else" statement ]
import_statement ::= "import" ( ( package_name "." "*" ";" ) | ( class_name | interface_name ) ) ";"
integer_literal ::= ( ( "1..9" { "0..9" } ) | { "0..7" } | ( "0" "x" "0..9a..f" { "0..9a..f" } ) ) [ "l" ]
interface_declaration ::= { modifier } "interface" identifier [ "extends" interface_name { "," interface_name } ] "{" { field_declaration } "}"
interface_name ::= identifier | ( package_name "." identifier )
literal_expression ::= integer_literal| float_literal | string | character 
logical_expression ::=  ( "!" expression ) | ( expression ( "ampersand" | "ampersand=" | "|" | "|=" | "^" | "^="  | ( "ampersand" "ampersand" ) | "||=" | "%" | "%=" ) expression ) | ( expression "?" expression ":" expression ) | "true" | "false"
method_declaration ::= { modifier } type identifier "(" [ parameter_list ] ")" { "[" "]" } ( statement_block | ";" )
modifier ::= "public" | "private" | "protected" | "static" | "final" | "native" | "synchronized" | "abstract" | "threadsafe" | "transient"
numeric_expression ::= ( ( "-" | "++" | "--" ) expression ) | ( expression ( "++"  | "--" ) ) | ( expression ( "+" | "+=" | "-" | "-=" | "*" | "*=" | "/" | "/=" | "%" | "%=" )  expression )
package_name ::= identifier | ( package_name "." identifier )
package_statement ::= "package" package_name ";"


parameter ::= type identifier { "[" "]" }
parameter_list ::= parameter { "," parameter }
statement  ::= variable_declaration | ( expression ";" ) | ( statement_block ) | ( if_statement ) | ( do_statement ) | ( while_statement ) | ( for_statement ) | ( try_statement ) | ( switch_statement ) | ( "synchronized" "(" expression ")" statement ) | ( "return" [ expression ] ";" ) | ( "throw" expression ";" ) | ( identifier ":" statement ) | ( "break" [ identifier ] ";" ) | ( "continue" [ identifier ] ";" ) | ( ";" )
statement_block ::= "{" { statement } "}"
static_initializer  ::= "static" statement_block
string ::= "''" { character } "''"
string_expression ::= ( expression ( "+" | "+=" ) expression )
switch_statement ::= "switch" "(" expression ")" "{" { ( "case" expression ":" ) | ( "default" ":" ) | statement } "}"
testing_expression ::= ( expression ( ">" | "<" | ">=" | "<=" | "==" | "!=" ) expression )
try_statement ::= "try" statement { "catch" "(" parameter ")" statement } [ "finally" statement ]
type ::= type_specifier { "[" "]" }
type_declaration ::= [ doc_comment ] ( class_declaration | interface_declaration ) ";"
type_specifier ::= "boolean" | "byte" | "char" | "short" | "int" | "float" | "long" | "double" | class_name | interface_name 
variable_declaration ::= { modifier } type variable_declarator { "," variable_declarator } ";"
variable_declarator ::= identifier { "[" "]" } [ "=" variable_initializer ]
variable_initializer ::= expression | ( "{" [ variable_initializer { "," variable_initializer } [ "," ] ] "}" )
while_statement ::= "while" "(" expression ")" statement



