import java_cup.runtime.*;



parser code {:

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
                   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            m.append(" in line "+(s.left));
            m.append(", column "+(s.right));

        }

        m.append(" : "+message);

        /* Print the contents of the StringBuilder 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
    }
    /*

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
    */
:};

// terminais
terminal CLASS, EXTENDS, IMPLEMENTS, INTERFACE, NEW, BREAK, CASE;
terminal CONTINUE, DEFAULT, DO, IF, ELSE, FOR, RETURN, SWITCH;
terminal WHILE, ASSERT, TRY, CATCH, FINALLY, THROW, THROWS, IMPORT;
terminal PACKAGE, BYTE, CONST, ABSTRACT, FINAL, NATIVE, SYNCHRONIZED;
terminal TRANSIENT, VOLATILE,SUPER, STRICTFP, PUBLIC, PROTECTED, PRIVATE;
terminal STATIC, VOID, NULL, THIS, INSTANCEOF, BOOLEAN, URSHIFTEQ;
terminal CHAR, SHORT, INT, FLOAT, LONG, DOUBLE, STRING, TRUE, FALSE;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON;
terminal COMMA, DOT, EQUAL, GREATER, LESS, NOT, BITNOT, QUESTION;
terminal COLON, EQEQ, LTEQ, GTEQ,GOTO, NOTEQ, ANDAND, OROR, PLUSPLUS;
terminal MINUSMINUS, PLUS, MINUS, MULT, DIV, AND, OR, XOR, MOD;
terminal LSHIFT, RSHIFT, URSHIFT, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, input_character, escape_character;
terminal ANDEQ, OREQ, XOREQ, MODEQ, LSHIFTEQ, RSHIFTEQ, ID, NUMERO, COMENTARIO;
terminal  a , b , c , d , e , f , A , B , C , D , E , F, x, X, l, L, escape_sequence, except;
terminal STRING_LITERAL;
// nao terminais


non terminal arglist, bit_expression, casting_expression, character;
non terminal class_declaration, class_name, compilation_unit, constructor_declaration;
non terminal creating_expression,decimal_digits,doc_comment,do_statement;
non terminal exponent_part,expression,field_declaration,float_literal;
non terminal float_type_suffix,for_statement,identifier,if_statement;
non terminal import_statement,integer_literal,interface_declaration,interface_name;
non terminal literal_expression,logical_expression,method_declaration,modifier;
non terminal numeric_expression,package_name,package_statement,parameter;
non terminal parameter_list,statement,statement_block,static_initializer;
non terminal string, string_expression,switch_statement,testing_expression;
non terminal try_statement,type, type_declaration,type_specifier, variable_declaration;
non terminal variable_declarator, variable_initializer, hile_statement;
non terminal expressions_e, import_statement_e,type_declaration_e, unique_expression;
non terminal comparative_expression, opr_reg, modifier_e, extends_e,implements_e;
non terminal interfaces_name_e,field_declaration_e, class_or_interface_declaration;
non terminal parameter_list_e,expression_type,expression_type_specifier,arglist_e;
non terminal parameters_e,signal,symbolic_expressions,class_or_interface_name;



compilation_unit ::= package_statement import_statement_e type_declaration_e;

identifier ::= ID;

modifier ::= PUBLIC | PRIVATE | PROTECTED | STATIC 
           | FINAL | NATIVE | SYNCHRONIZED | ABSTRACT 
           | TRANSIENT;
	

package_statement ::= PACKAGE package_name SEMICOLON;

package_name ::= identifier
               |package_name DOT identifier;

import_statement_e ::= 
					  | import_statement;

type_declaration_e ::= 
					| type_declaration;

class_declaration ::= modifier_e CLASS identifier extends_e implements_e LBRACE field_declaration_e RBRACE;


arglist ::= expression expressions_e; 

expressions_e ::= |
                  COMMA expression;

bit_expression ::= unique_expression  
				 | comparative_expression;

unique_expression ::= BITNOT expression;

comparative_expression ::= expression  opr_reg expression;

opr_reg ::=  RSHIFTEQ 
          | LSHIFT 
          | RSHIFT
          | URSHIFT;  
          
          
casting_expression ::= LPAREN type RPAREN expression;

character ::= STRING_LITERAL;


class_name ::= identifier 
			 | package_name DOT identifier;

modifier_e ::= 
             | modifier;
             
extends_e ::= 
			| EXTENDS class_name;	

implements_e ::=
				| IMPLEMENTS interface_name interfaces_name_e; 
				
interfaces_name_e ::= 
					| COMMA interface_name; 
					
field_declaration_e ::=
					  | field_declaration;

type_declaration ::= class_or_interface_declaration;

class_or_interface_declaration ::= 	class_declaration 
                                 | interface_declaration;
                                 		
constructor_declaration ::=  modifier_e identifier LPAREN  parameter_list_e RPAREN statement_block;

parameter_list_e ::= 
				   | parameter_list;

creating_expression ::= NEW expression_type;

expression_type ::= class_name LPAREN arglist_e RPAREN  
                  | type_specifier expression_type_specifier  
                  | LPAREN expression RPAREN;  

expression_type_specifier ::= LBRACK expression RBRACK
							| LBRACK RBRACK
							| ;

arglist_e ::= 
			| arglist;

decimal_digits ::= NUMERO;

parameter ::= type identifier expression_type_specifier;

parameter_list ::= parameter parameters_e;

parameters_e ::= 
			   | COMMA parameter;
				


do_statement ::= DO statement WHILE LPAREN expression RPAREN SEMICOLON;
exponent_part ::= E signal decimal_digits;

signal ::= PLUS 
         | MINUS;

expression ::= numeric_expression | testing_expression | logical_expression 
             | string_expression | bit_expression | casting_expression 
             | creating_expression | literal_expression | NULL | SUPER 
             | THIS | identifier |  LPAREN expression RPAREN  
             |  expression symbolic_expressions;
                 
symbolic_expressions ::=  LPAREN  arglist_e RPAREN  
                 |  LBRACK expression RBRACK 
                 |  DOT expression 
                 |  COMMA expression 
                 |  INSTANCEOF  class_or_interface_name;    
 
class_or_interface_name ::= class_name
						  | interface_name;

/*                 
field_declaration ::= (( method_declaration | constructor_declaration | variable_declaration ) ) | static_initializer | ";"
float_literal  ::=  ( decimal_digits "." [ decimal_digits ] [ exponent_part ] [ float_type_suffix ] ) | ( "." decimal_digits [ exponent_part ] [ float_type_suffix ] ) | ( decimal_digits [ exponent_part ] [ float_type_suffix ] )



float_type_suffix ::= "f" | "d"
for_statement ::= "for" "(" ( variable_declaration | ( expression ";" ) | ";" ) [ expression ] ";"  [ expression ] ";" ")" statement
identifier ::= "a..z,$,_" { "a..z,$,_,0..9,unicode character over 00C0" }
if_statement ::= "if" "(" expression ")" statement [ "else" statement ]
import_statement ::= "import" ( ( package_name "." "*" ";" ) | ( class_name | interface_name ) ) ";"
integer_literal ::= ( ( "1..9" { "0..9" } ) | { "0..7" } | ( "0" "x" "0..9a..f" { "0..9a..f" } ) ) [ "l" ]
interface_declaration ::= { modifier } "interface" identifier [ "extends" interface_name { "," interface_name } ] "{" { field_declaration } "}"
interface_name ::= identifier | ( package_name "." identifier )
literal_expression ::= integer_literal| float_literal | string | character 
logical_expression ::=  ( "!" expression ) | ( expression ( "ampersand" | "ampersand=" | "|" | "|=" | "^" | "^="  | ( "ampersand" "ampersand" ) | "||=" | "%" | "%=" ) expression ) | ( expression "?" expression ":" expression ) | "true" | "false"
method_declaration ::= { modifier } type identifier "(" [ parameter_list ] ")" { "[" "]" } ( statement_block | ";" )
numeric_expression ::= ( ( "-" | "++" | "--" ) expression ) | ( expression ( "++"  | "--" ) ) | ( expression ( "+" | "+=" | "-" | "-=" | "*" | "*=" | "/" | "/=" | "%" | "%=" )  expression )
package_name ::= identifier | ( package_name "." identifier )



statement  ::= variable_declaration | ( expression ";" ) | ( statement_block ) | ( if_statement ) | ( do_statement ) | ( while_statement ) | ( for_statement ) | ( try_statement ) | ( switch_statement ) | ( "synchronized" "(" expression ")" statement ) | ( "return" [ expression ] ";" ) | ( "throw" expression ";" ) | ( identifier ":" statement ) | ( "break" [ identifier ] ";" ) | ( "continue" [ identifier ] ";" ) | ( ";" )
statement_block ::= "{" { statement } "}"
static_initializer  ::= "static" statement_block
string ::= "''" { character } "''"
string_expression ::= ( expression ( "+" | "+=" ) expression )
switch_statement ::= "switch" "(" expression ")" "{" { ( "case" expression ":" ) | ( "default" ":" ) | statement } "}"
testing_expression ::= ( expression ( ">" | "<" | ">=" | "<=" | "==" | "!=" ) expression )
try_statement ::= "try" statement { "catch" "(" parameter ")" statement } [ "finally" statement ]
type ::= type_specifier { "[" "]" }

type_specifier ::= "boolean" | "byte" | "char" | "short" | "int" | "float" | "long" | "double" | class_name | interface_name 
variable_declaration ::= { modifier } type variable_declarator { "," variable_declarator } ";"
variable_declarator ::= identifier { "[" "]" } [ "=" variable_initializer ]
variable_initializer ::= expression | ( "{" [ variable_initializer { "," variable_initializer } [ "," ] ] "}" )
while_statement ::= "while" "(" expression ")" statement



*/
